  <html>
<head>
  <title>xlagauchex</title>
  <style>
    body { margin: 0; }
  canvas
  { width: 100%; height: 100%; }
  </style>
</head>
<body>

  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>

  <script>

"use strict";

var time, scene, camera, renderer, controls;
var width, height;
var loader;
var fleshGeometry, fleshMaterial, fleshMesh;
var ceilingGeometry, ceilingMaterial, ceilingMesh;
var sphereGeometryLink1, sphereGeometryMaterial, linkMesh1;
var ambientLight, light1, light2, light3
var listener, sound1, audioLoader;
var clickableObjects;
var mouse, raycaster, intersects;
var i;
var textureLoader, textureCube, equirectShader, equirectMaterial, textureEquirec;

init();
animate();

function init( )
{
  scene = new THREE.Scene( );
  camera = new THREE.PerspectiveCamera ( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.z = 3;
  camera.position.x = -1;
  camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

  renderer = new THREE.WebGLRenderer ( );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild ( renderer.domElement );
  controls = new THREE.OrbitControls( camera, renderer.domElement );

  window.addEventListener ( 'resize', function( )
  {
    width = window.innerWidth;
    height = window.innerHeight;
    renderer.setSize( width, height );
    camera.aspect = width / height;
    camera.updateProjectionMatrix( );

  } );

  textureLoader = new THREE.TextureLoader();
	textureEquirec = textureLoader.load( "textures/cloudsFleshSmall.jpg" );
	textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
	textureEquirec.magFilter = THREE.LinearFilter;
	textureEquirec.minFilter = THREE.LinearMipMapLinearFilter;

  // equirectShader = THREE.ShaderLib[ "equirect" ];
  //
  // equirectMaterial = new THREE.ShaderMaterial( {
  //     fragmentShader: equirectShader.fragmentShader,
  //     vertexShader: equirectShader.vertexShader,
  //     uniforms: equirectShader.uniforms,
  //     depthWrite: false,
  //     side: THREE.BackSide
  // } );

  loader = new THREE.ObjectLoader( );
  loader.load( 'models/laptop/laptopnowin.json', function ( laptop )
    {
      laptop.position.set( 0, -4, 12 );
      laptop.scale.set( 4, 4, 4);
      scene.add( laptop );
    }
  );

  listener = new THREE.AudioListener( ); // create an AudioListener and add it to the camera
  camera.add( listener );
  sound1 = new THREE.PositionalAudio( listener ); // create the PositionalAudio object (passing in the listener)
  audioLoader = new THREE.AudioLoader( );
  audioLoader.load( 'sounds/Love_1.mp3', function( buffer ) // load a sound and set it as the PositionalAudio object's buffer
    {
  	   sound1.setBuffer( buffer );
  	   sound1.setRefDistance( 4 );
  	   sound1.play( );
    }
  );

    fleshGeometry = new THREE.IcosahedronGeometry( 1, 1, 1 );
    fleshMaterial = new THREE.MeshLambertMaterial ( { map: new THREE.TextureLoader( ).load( 'img/internalFlesh.jpg' ), side: THREE.DoubleSide } );
    fleshMesh = new THREE.Mesh( fleshGeometry, fleshMaterial );
    scene.add( fleshMesh );
    fleshMesh.add( sound1 );

    ceilingGeometry = new THREE.CubeGeometry( 10, 0.001, 10 );
    ceilingMaterial = new THREE.MeshPhongMaterial( { map: new THREE.TextureLoader( ).load ( 'img/clouds.jpg' ), side:
    THREE.DoubleSide } );
    ceilingMesh = new THREE.Mesh( ceilingGeometry, ceilingMaterial );
    ceilingMesh.position.y = 1.5;
    // ceilingMesh.rotation.x = Math.PI / 2; // rotates object 90 degrees
    scene.add( ceilingMesh );

    ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.8 );
    light1 = new THREE.PointLight ( 0xFFFFFF, 1, 50 );
    light2 = new THREE.PointLight ( 0xFFFFFF, 1, 50 );
    light3 = new THREE.PointLight ( 0xFF00FFF, 1, 50 );

    scene.add( ambientLight );
    scene.add( light1 );
    scene.add( light2 );
    scene.add( light3 );

    clickableObjects = [];

    // for( i = 0; i < 10; i++ )
  // {

  // ( 1, 11, 2 );
    sphereGeometryLink1 = new THREE.SphereGeometry( 1.1, 12, 2 );
    sphereGeometryMaterial = new THREE.MeshLambertMaterial( { envMap: textureEquirec } )
    linkMesh1 = new THREE.Mesh( sphereGeometryLink1, sphereGeometryMaterial );
    linkMesh1.userData = { URL: "https://en.wikipedia.org/wiki/Deleuze_and_Guattari" };
    linkMesh1.position.y = 3;
    scene.add( linkMesh1 );
    clickableObjects.push( linkMesh1 );

    // params = { Equirectangular: function () {
    //         cubeMesh.material = equirectMaterial;
    //         cubeMesh.visible = true;
    //         sphereMaterial.envMap = textureEquirec;
    //         sphereMaterial.needsUpdate = true;
    //       },
    //         Refraction: false
    //       };

    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
  // }
}

function onDocumentMouseMove( event ) {
		mouse = new THREE.Vector2( );
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    raycaster = new THREE.Raycaster( );
    raycaster.setFromCamera( mouse, camera );
		intersects = raycaster.intersectObjects( clickableObjects );

    if( intersects.length > 0 )
      {
      for ( i = 0;  intersects.length > 0 && i < intersects.length; i++ )
        {
          // intersects[i].object.rotation.x = 0;
        }
      }
    else
      {
        linkMesh1.rotation.x += 0.1;
      }
}

function onDocumentMouseUp( event ) {
    event.preventDefault( );
    if( intersects.length > 0 )
    {
        //  for ( i = 0;  intersects.length > 0 && i < intersects.length; i++)
        //  {
            window.open( intersects[0].object.userData.URL );
        //  }
    }
    else {

    }
}

    function animate( )
    {
      requestAnimationFrame( animate );

      fleshMesh.rotation.x += 0.02;
      fleshMesh.rotation.y += 0.005;

      linkMesh1.rotation.y += 0.005;
      // linkMesh1.rotation.x += 0.0005;

      time = Date.now( ) * 0.0005;

      light1.position.x = Math.sin( time * 2) * 30;
      light1.position.y = Math.cos( time * 8) * 40;
      light1.position.z = Math.cos( time * 4) * 30;

      light2.position.x = Math.cos( time * 3) * 30;
      light2.position.y = Math.sin( time * 7) * 40;
      light2.position.z = Math.sin( time * 10) * 30;

      light3.position.x = Math.sin( time * 3) * 30;
      light3.position.y = Math.cos( time * 4) * 40;
      light3.position.z = Math.sin( time * 5) * 30;

      renderer.render( scene, camera );
    }


</script>
</body>
</html>
