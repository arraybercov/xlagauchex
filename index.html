  <html>
<head>
  <title>xlagauchex</title>
  <style>
    body { margin: 0; }
  canvas
  { width: 100%; height: 100%; }
  </style>
</head>
<body>

  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>

  <script>

"use strict";

var time, scene, camera, renderer, controls;
var width, height;
var loader;
var fleshGeometry, fleshMaterial, fleshMesh;
var ceilingGeometry, ceilingMaterial, ceilingMesh;
var sphereGeometryLink1, sphereGeometryMaterial, linkMesh1;
var ambientLight, light1, light2, light3
var listener, sound1, audioLoader;
var clickableObjects;
var mouse, raycaster, intersects;
var cubeCamera2;
var laptopv, laptopScreen;

init();
animate();

function init( )
{
  scene = new THREE.Scene( );
  camera = new THREE.PerspectiveCamera ( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.z = 3;
  camera.position.x = -1;
  camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );


  renderer = new THREE.WebGLRenderer ( { antialias:true } );
  renderer.setSize( window.innerWidth, window.innerHeight );

  document.body.appendChild ( renderer.domElement );

  controls = new THREE.OrbitControls( camera, renderer.domElement );

  window.addEventListener ( 'resize', function( )
  {
    width = window.innerWidth;
    height = window.innerHeight;
    renderer.setSize( width, height );
    camera.aspect = width / height;
    camera.updateProjectionMatrix( );

  } );

  cubeCamera2 = new THREE.CubeCamera( 1, 10000, 256 );
  cubeCamera2.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
  scene.add( cubeCamera2 );

  loader = new THREE.ObjectLoader( );
  loader.load( 'models/laptop/laptopnowin.json', function ( laptop )
    {
      laptopv = laptop;
      laptopv.position.set( 0, -4, 12 );
      laptopv.scale.set( 4, 4, 4);
      laptopv.children[0].children[3].visible = true;

      // laptopScreen = laptopv.children[0].children[3].clone();
      // laptopv.children[0].add(laptopScreen)
      // laptopScreen.visible = true;
      // laptopScreen.material.color.setHex( 0xffff00 );
      //
      // laptopScreen.position.y = 2;
      // laptopScreen.position.z = 1;
      // laptopScreen.material.transparent = true;
      // laptopScreen.material.opacity = 0.7;
      // laptopScreen.material.shininess = 100;
      scene.add( laptopv );
      // scene.add( laptopScreen )
      // laptopScreen.scale.set( 0.2, 0.2, 0.2);
      // laptopScreen.position.set( 0, 0, 0 );

    }
  );

  listener = new THREE.AudioListener( ); // create an AudioListener and add it to the camera
  camera.add( listener );
  sound1 = new THREE.PositionalAudio( listener ); // create the PositionalAudio object (passing in the listener)
  audioLoader = new THREE.AudioLoader( );
  audioLoader.load( 'sounds/Love_1.mp3', function( buffer ) // load a sound and set it as the PositionalAudio object's buffer
    {
  	   sound1.setBuffer( buffer );
  	   sound1.setRefDistance( 4 );
  	   sound1.play( );
    }
  );

    fleshGeometry = new THREE.IcosahedronGeometry( 1, 1, 1 );
    fleshMaterial = new THREE.MeshLambertMaterial ( { map: new THREE.TextureLoader( ).load( 'img/internalFlesh.jpg' ), side: THREE.DoubleSide } );
    fleshMesh = new THREE.Mesh( fleshGeometry, fleshMaterial );
    scene.add( fleshMesh );
    fleshMesh.add( sound1 );

    clickableObjects = [];

    ceilingGeometry = new THREE.PlaneGeometry( 10, 10 );
    ceilingMaterial = new THREE.MeshPhongMaterial( { map: new THREE.TextureLoader( ).load ( 'img/clouds.jpg' ), side:
    THREE.DoubleSide } );
    ceilingMesh = new THREE.Mesh( ceilingGeometry, ceilingMaterial );
    ceilingMesh.position.y = 1.5;
    ceilingMesh.rotation.x = Math.PI / 2; // rotates object 90 degrees
    scene.add( ceilingMesh );
    clickableObjects.push( ceilingMesh );

    ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.8 );
    light1 = new THREE.PointLight ( 0xFFFFFF, 1, 50 );
    light2 = new THREE.PointLight ( 0xFFFFFF, 1, 50 );
    light3 = new THREE.PointLight ( 0xFF00FFF, 1, 50 );

    scene.add( ambientLight );
    scene.add( light1 );
    scene.add( light2 );
    scene.add( light3 );

    sphereGeometryLink1 = new THREE.SphereGeometry( 1, 12, 2 );
    sphereGeometryMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeCamera2.renderTarget.texture } );
    linkMesh1 = new THREE.Mesh( sphereGeometryLink1, sphereGeometryMaterial );
    linkMesh1.userData = { URL: "https://soundcloud.com/lagauche" };
    linkMesh1.position.y = 3;
    linkMesh1.name = "soundcloudObject";
    scene.add( linkMesh1 );
    clickableObjects.push( linkMesh1 );

    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );

}

function onDocumentMouseMove( event ) {
		mouse = new THREE.Vector2( );
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    raycaster = new THREE.Raycaster( );
    raycaster.setFromCamera( mouse, camera );
		intersects = raycaster.intersectObjects( clickableObjects );

    if( intersects.length > 0 && intersects[0].object == linkMesh1 )
      {
      // for ( i = 0;  intersects.length > 0 && i < intersects.length; i++ )
      //   {
      //     intersects[i].object.rotation.x = 0;
      //   }
      }
    else
      {
        linkMesh1.rotation.x += 0.1;
        // ceilingMesh.rotation.z += 0.02;
      }
}

function onDocumentMouseUp( event ) {
    event.preventDefault( );
    if( intersects.length > 0 && intersects[0].object == linkMesh1 ) {
        window.open( intersects[0].object.userData.URL );
    }
}

    function animate( )
    {
      requestAnimationFrame( animate );

      fleshMesh.rotation.x += 0.02;
      fleshMesh.rotation.y += 0.005;

      linkMesh1.rotation.y += 0.005;
      // linkMesh1.rotation.x += 0.0005;

      time = Date.now( ) * 0.0005;

      light1.position.x = Math.sin( time * 2) * 30;
      light1.position.y = Math.cos( time * 8) * 40;
      light1.position.z = Math.cos( time * 4) * 30;

      light2.position.x = Math.cos( time * 3) * 30;
      light2.position.y = Math.sin( time * 7) * 40;
      light2.position.z = Math.sin( time * 10) * 30;

      light3.position.x = Math.sin( time * 3) * 30;
      light3.position.y = Math.cos( time * 4) * 40;
      light3.position.z = Math.sin( time * 5) * 30;

      // ceilingMesh.rotation.y = Math.cos( time * 1) + 0;



      ceilingMesh.geometry.vertices[0].set(
        Math.sin( time * 1 ) + -5,
        Math.cos( time * 1 ) * 0.2 + 5.2,
        0 );

      ceilingMesh.geometry.vertices[3].set(
        5,
        Math.cos( time * 1.3 ) * 0.4 + -5,
        Math.sin( time * 1.3 ) * 0.3);

  ceilingMesh.geometry.verticesNeedUpdate = true;


      linkMesh1.visible = false;
      cubeCamera2.position.copy( cubeCamera2.position );
      cubeCamera2.update( renderer, scene );
      linkMesh1.visible = true;

      renderer.render( scene, camera );
    }


</script>
</body>
</html>
